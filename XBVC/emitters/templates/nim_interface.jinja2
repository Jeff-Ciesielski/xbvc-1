import cobs
import bitvec
import options
import threadpool
import tables
import rlocks
import os
import strformat

const
  ResponsePollMS = 125
  ResponseTimeout = 1000
  MaxPrecision = 8

type
  SplitFloat = object
    whole: int32
    frac: uint32

type
{% for enum in enumerations%}
  {{enum.pascal_name}}* = enum
  {% for val in enum.prefixed_camel_vals%}
    {{val}} = {{loop.index - 1}},
  {% endfor %}

{% endfor %}

  XBVCMessageType* = enum
{% for msg in messages %}
    xm{{msg.pascal_name}} = {{msg.msg_id}},
{% endfor %}

  XBVCMessageBase = object of RootObj

{% for msg in messages %}
  {{msg.pascal_name}}Message* = object of XBVCMessageBase
    {% for m in msg.members %}
      {% if m.d_len == 1 %}
    {{m.camel_name}}*: {{m.nim_d_type}}
      {% else %}
    {{m.camel_name}}*: array[0..{{m.d_len|int - 1}}, {{m.nim_d_type}}]
    {% endif %}
    {% endfor %}
{% endfor %}

  XBVCMessage* = object
    case kind: XBVCMessageType
{% for msg in messages %}
    of xm{{msg.pascal_name}}:
      {{msg.name.lower()}}*: {{msg.pascal_name}}Message
{% endfor %}
    else: discard


proc splitFloat(v: float, precision: int=MaxPrecision): SplitFloat =
  var v = v
  var precision = precision

  result.whole = v.int32
  v = v - result.whole.float
  v = abs(v)

  precision = max(MaxPrecision, precision)

  while precision > 0 and v > 0:
    result.frac *= 10
    v *= 10
    result.frac += v.uint32
    v = v - (v.uint32).float
    dec precision


proc combineFloat(s: SplitFloat): float =
  var resultWhole = s.whole.float
  var resultFrac = 0.0
  var s = s

  while s.frac > 0.uint32:
    resultFrac += (s.frac mod 10).float
    resultFrac /= 10
    s.frac = (s.frac.int / 10.int).uint32

  if resultWhole < 0:
    resultFrac *= -1

  return resultWhole + resultFrac


proc `==`*[T: ref XBVCMessageBase](a, b: T): bool =
  a[] == b[]


template `$`*[T: ref XBVCMessageBase](a: T): string =
  $a[]

{% for msg in messages %}
proc serialize*(m: {{msg.pascal_name}}Message): seq[byte] =
  result = bitvec.encode(xm{{msg.pascal_name}}.uint)
  {% for m in msg.members %}
  {% if m.d_len == 1 %}
    {% if m.d_type == "f32" %}
  let sf{{loop.index}} = splitFloat(m.{{m.camel_name}})
  result &= bitvec.encode(sf{{loop.index}}.whole)
  result &= bitvec.encode(sf{{loop.index}}.frac)
    {% else %}
  result &= bitvec.encode(m.{{m.camel_name}})
    {% endif %}
  {% else %}
  for val in m.{{m.camel_name}}:
    {% if m.d_type == "f32" %}
    let sf{{loop.index}} = splitFloat(val)
    result &= bitvec.encode(sf{{loop.index}}.whole)
    result &= bitvec.encode(sf{{loop.index}}.frac)
    {% else %}
    result &= bitvec.encode(val)
    {% endif %}
  {% endif %}
  {% endfor %}

proc deserialize{{msg.pascal_name}}*(s: seq[byte]): Option[{{msg.pascal_name}}Message] =
  var resObj = {{msg.pascal_name}}Message()
  var rem = @s

  {% for m in msg.members %}
    {% if m.d_type == "f32" %}
  var sf{{loop.index}}: SplitFloat
    {% endif %}
  {% if m.d_len == 1 %}
    {% if m.d_type == "f32" %}
  var decRes{{loop.index}}a: Option[int32]
  (decRes{{loop.index}}a, rem) = bitvec.decode[int32](rem)
  if decRes{{loop.index}}a.isNone():
    return
  sf{{loop.index}}.whole = decRes{{loop.index}}a.get()
  var decRes{{loop.index}}b: Option[uint32]
  (decRes{{loop.index}}b, rem) = bitvec.decode[uint32](rem)
  if decRes{{loop.index}}b.isNone():
    return
  sf{{loop.index}}.frac = decRes{{loop.index}}b.get()
  resObj.{{m.camel_name}} = combineFloat(sf{{loop.index}})
    {% else %}
  var decRes{{loop.index}}: Option[{{m.nim_d_type}}]
  (decRes{{loop.index}}, rem) = bitvec.decode[{{m.nim_d_type}}](rem)
  if decRes{{loop.index}}.isNone():
    return
  resObj.{{m.camel_name}} = decRes{{loop.index}}.get()
    {% endif %}
  {% else %}
  for idx in 0..resObj.{{m.camel_name}}.high:
    {% if m.d_type == "f32" %}
    var decRes{{loop.index}}a: Option[int32]
    var decRes{{loop.index}}b: Option[uint32]
    (decRes{{loop.index}}a, rem) = bitvec.decode[int32](rem)
    if decRes{{loop.index}}a.isNone():
      return
    (decRes{{loop.index}}b, rem) = bitvec.decode[uint32](rem)
    if decRes{{loop.index}}b.isNone():
      return
    sf{{loop.index}}.whole = decRes{{loop.index}}a.get()
    sf{{loop.index}}.frac = decRes{{loop.index}}b.get()
    resObj.{{m.camel_name}}[idx] = sf{{loop.index}}.combineFloat()
    {% else %}
    var decRes{{loop.index}}: Option[{{m.nim_d_type}}]
    (decRes{{loop.index}}, rem) = bitvec.decode[{{m.nim_d_type}}](rem)
    if decRes{{loop.index}}.isNone():
      return
    resObj.{{m.camel_name}}[idx] = decRes{{loop.index}}.get()
    {% endif %}
  {% endif %}
  {% endfor %}
  result = some(resObj)

{% endfor %}

type
  XBVCCallback* = proc(msg: XBVCMessage)
  XBVCCallbackTable = Table[XBVCMessageType, XBVCCallback]
  XBVCEdgePoint* = ref object
    rxChan*: Channel[Option[byte]]
    txChan*: Channel[Option[byte]]
    callbacks: XBVCCallbackTable
    responseChan: Channel[XBVCMessage]
    responseLock: RLock
    expectedResponse: Channel[XBVCMessageType]


proc newEdgePoint*(): XBVCEdgePoint =
  new(result)
  result.callbacks = initTable[XBVCMessageType, XBVCCallback]()
  result.responseChan.open()
  result.expectedResponse.open(1)
  initRLock(result.responseLock)

proc registerCallback*(ep: XBVCEdgePoint, msgType: XBVCMessageType, cb: XBVCCallback) =
  # TODO: Allow multiple callbacks?  Throw an error? TBD
  ep.callbacks[msgType] = cb

proc decodeMessage(input: seq[byte], msgID: XBVCMessageType): Option[XBVCMessage] =
  var msg: XBVCMessage
  case msgID
{% for msg in messages %}
  of xm{{msg.pascal_name}}:
    let innerMsg: Option[{{msg.pascal_name}}Message] = input.deserialize{{msg.pascal_name}}()
    if innerMsg.isNone():
      return
    msg = XBVCMessage(kind:xm{{msg.pascal_name}}, {{msg.name.lower()}}:innerMsg.get())
    result = some(msg)
{% endfor %}

proc rxLoop(ch: ptr Channel[Option[byte]], callbacks: XBVCCallbackTable,
            rspChan: ptr Channel[XBVCMessage], expectedResponse: ptr Channel[XBVCMessageType]) =
  var buf: seq[byte] = @[]
  while true:
    let rune = ch[].recv()
    if rune.isNone:
      return
    buf.add(rune.get())
    if buf[^1] != 0.byte:
      continue

    buf = cobs.decode(buf)
    var msgID: Option[uint32]
    (msgID, buf) = bitvec.decode[uint32](buf)
    if msgID.isNone():
      echo "Got corrupt message"
      buf = @[]
      continue

    let msgWrapper = decodeMessage(buf, msgID.get().XBVCMessageType)

    if msgWrapper.isNone():
      echo &"Unable to decode message from buffer: {buf}"
      buf = @[]
      continue

    let msg = msgWrapper.get()

    var
      awaitingResponse = false
      responseType: XBVCMessageType

    (awaitingResponse, responseType) = expectedResponse[].tryRecv()

    if awaitingResponse and responseType == msg.kind:
      rspChan[].send(msg)
    else:
      if awaitingResponse:
        expectedResponse[].send(responseType)
      callbacks[msg.kind](msg)
    buf = @[]

proc send(ep: XBVCEdgePoint, buf: seq[byte]) =
  let data = cobs.encode(buf)
  for d in data:
    ep.txChan.send(some(d))

proc send*[T](ep: XBVCEdgePoint, msg: T) =
  let data = serialize(msg)
  ep.send(data)

proc sendWithResponse*[T](ep: XBVCEdgePoint, msg: T, responseType: XBVCMessageType): Option[XBVCMessage] =
  var respChan: Channel[XBVCMessage]
  respChan.open()

  withRLock(ep.responseLock):
    # This will be set to None by the receive thread to avoid stuffing
    # extra responses into the channel
    ep.expectedResponse.send(responseType)
    let data = serialize(msg)
    ep.send(data)
    var
      dataAvailable = false
      response: XBVCMessage
      elapsedTime = 0

    while not dataAvailable and elapsedTime < ResponseTimeout:
      sleep(ResponsePollMS)
      elapsedTime += ResponsePollMS
      (dataAvailable, response) = tryRecv(ep.responseChan)

    if not dataAvailable:
      # Since the default option is "None", we can just bail
      return

    result = some(response)


proc start*(ep: XBVCEdgePoint) =
  ep.rxChan = Channel[Option[byte]]()
  ep.txChan = Channel[Option[byte]]()
  ep.rxChan.open()
  ep.txChan.open()
  spawn rxLoop(ep.rxChan.addr, ep.callbacks, ep.responseChan.addr, ep.expectedResponse.addr)

proc stop*(ep: XBVCEdgePoint) =
  ep.txChan.send(none(byte))
  ep.rxChan.send(none(byte))

  # Force a context switch to allow the receiving threads to end
  sleep(1)
  ep.rxChan.close()
  ep.txChan.close()

when isMainModule:
  let msg = {{messages[0].pascal_name}}Message()
  let serData = msg.serialize{{messages[0].pascal_name}}()
  let desMsg = serData.deserialize{{messages[0].pascal_name}}()
  assert desMsg.isSome()
  assert msg == desMsg.get()
  echo "Sanity Tests Passed"
